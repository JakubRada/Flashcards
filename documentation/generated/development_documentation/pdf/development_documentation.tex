\documentclass[12pt]{article}
\usepackage[a4paper, total={18cm, 25cm}]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[parfill]{parskip}
\usepackage[hidelinks]{hyperref}
\usepackage{xcolor}
\providecommand{\tightlist}{\setlength{\itemsep}{1pt}\setlength{\parskip}{1pt}}

\definecolor{codehighlight}{RGB}{28,93,153}
\let\oldtexttt\texttt
\renewcommand{\texttt}[1]{\oldtexttt{\textcolor{codehighlight}{#1}}}

\begin{document}
\begin{center}
  \textbf{\Huge Flashcards}\\
  \vspace{0.2cm}
  \rule{\textwidth}{0.5pt}
\end{center}
\tableofcontents
\begin{center}
  \rule{\textwidth}{0.5pt}
\end{center}
\hypertarget{overview}{%
\section{Overview}\label{overview}}

Flaschcards app has the same structure as a web application, main parts
are programmed using html, css and javascript, but is rendered using
Electron instead of conventional web browser. In addition, all the data
are saved into separate database, so both parts can be altered
independently. As server side app is used Django by Python and its run
on localhost. Visual part and server part are communicating
asynchronously through JSON requests.

\hypertarget{dependencies}{%
\section{Dependencies}\label{dependencies}}

App uses many dependencies. On the server side is used Django framework,
which also requires Python 3 (using the latest version is recommended).
On the user side is used electron to render all visual features instead
of web browser and it also requires Node.js. Bootstrap is used for
better looks of the application, contains of three files: css file,
which is altered to change some default colors, javascript file and
popper.js. For asynchronous changes and communication with the server is
used JQuery.

\begin{itemize}
\tightlist
\item
  Server side

  \begin{itemize}
  \tightlist
  \item
    Python 3.7 (\emph{www.python.org/downloads/windows/})
  \item
    Django 2.1.5 (installed by \texttt{pip\ install\ Django==2.1.5})
  \end{itemize}
\item
  User side

  \begin{itemize}
  \tightlist
  \item
    Node.js
  \item
    Electron (\emph{www.electronjs.org})
  \item
    Electron packager
    (\emph{www.github.com/electron-userland/electron-packager})
  \item
    Bootstrap precompiled files (downloaded from
    \emph{www.getbootstrap.com/docs/4.3/getting-started/download/})

    \begin{itemize}
    \tightlist
    \item
      css file, javascript file and popper.js
    \end{itemize}
  \item
    JQuery (\emph{www.jquery.com})
  \end{itemize}
\end{itemize}

\hypertarget{server-side}{%
\section{Server side}\label{server-side}}

As said above, all data are handled by Django running offline on
localhost. All files related to server are saved in \texttt{./server/}
folder. In the \texttt{./server/server/} folder are basic settings for
server app and in the \texttt{./server/cards/} folder are files unique
for this specific app. In this folder can be found models for database
objects and functions handling requests from user client.

\hypertarget{command-to-start-a-server}{%
\subsection{Command to start a server}\label{command-to-start-a-server}}

\texttt{python\ manage.py\ runserver\ localhost:8000}

\begin{itemize}
\tightlist
\item
  From \texttt{./server/} folder
\end{itemize}

\hypertarget{default-server-configuration}{%
\subsection{Default server
configuration}\label{default-server-configuration}}

\begin{itemize}
\tightlist
\item
  Files in \texttt{./server/server/}
\item
  Here have to be set all installed apps (only `cards' in this case),
  type database is used (sqlite3) and which urls will server for
  receiving requests (specified in `urls.py')
\item
  It also contains secret key for this database in case it was to be
  published online
\end{itemize}

\hypertarget{cards-app-configuration}{%
\subsection{Cards app configuration}\label{cards-app-configuration}}

All files in \texttt{./server/cards/}. For this app are important only
\texttt{models.py}, \texttt{urls.py} and \texttt{views.py}. Others are
either necessary for Django or are empty, without use in this case.

\hypertarget{models}{%
\subsubsection{Models}\label{models}}

Here are declared database objects with their variables and relations
among them. Each model serves as a template and creates table in the
database. Individual rows are connected among tables through
relationship fields.

\begin{itemize}
\tightlist
\item
  model \texttt{Tag(tag\_name,\ previous\_success\_rate,\ card\_count)}

  \begin{itemize}
  \tightlist
  \item
    \texttt{tag\_name} \ldots{} CharField (max. 100 characters);
    represents name of a specific tag
  \item
    \texttt{previous\_success\_rate} \ldots{} IntegerField; represents
    success rate of the last test of a specific tag
  \item
    \texttt{card\_count} \ldots{} IntegerField, optional (default=0);
    represents number of cards linked to a specific tag
  \item
    each variable has its \texttt{get} and \texttt{set} method to alter
    or return value
  \item
    \texttt{add\_card} and \texttt{remove\_card} methods serve to
    increase or decrease \texttt{card\_count} variable
  \end{itemize}
\item
  model \texttt{Card(card\_front,\ card\_back,\ tag\_count,\ tags)}

  \begin{itemize}
  \tightlist
  \item
    \texttt{card\_front} \ldots{} CharField (max. 200 characters);
    represents text shown on front side of a specific card
  \item
    \texttt{card\_back} \ldots{} CharField (max. 200 characters);
    represents text shown on back side of a specific card
  \item
    \texttt{tag\_count} \ldots{} IntegerField, optional (default=0);
    represents number of tags linked to a specific card
  \item
    \texttt{tags} \ldots{} ManyToManyField; links cards to tags and tags
    to cards

    \begin{itemize}
    \tightlist
    \item
      by running \texttt{tags.add(tag)} are tags connected to a specific
      card, \texttt{tags.remove(tag)} destroys the connection
    \item
      in each tag is simultaneously created variable \texttt{cards}
      where are stored connections with each card so these relations can
      be accessed from both ends
    \end{itemize}
  \item
    each variable has its \texttt{get} and \texttt{set} method to alter
    or return value
  \item
    \texttt{add\_tag} and \texttt{remove\_tag} methods serve to increase
    or decrease \texttt{tag\_count} variable
  \end{itemize}
\end{itemize}

\hypertarget{views-and-urls}{%
\subsubsection{Views and urls}\label{views-and-urls}}

Here are declared functions to handle incoming and outcoming Json and
Http requests from client. All requests and responses are happening
through Json objects in order to communicate better with JavaScript.

\begin{itemize}
\tightlist
\item
  request \texttt{cards}

  \begin{itemize}
  \tightlist
  \item
    request has to be sent on url \texttt{localhost:8000/cards/cards/}
  \item
    returns list of Json objects, each represents one card from database
  \item
    Json object does not contain all information -
    \texttt{\{id,\ card\_front,\ card\_back\}}
  \end{itemize}
\item
  request \texttt{tags}

  \begin{itemize}
  \tightlist
  \item
    request has to be sent on url \texttt{localhost:8000/cards/tags/}
  \item
    returns list of Json objects, each represents one tag from database
  \item
    Json object does not contain all information -
    \texttt{\{id,\ tag\_name\}}
  \end{itemize}
\item
  request \texttt{tag(tag\_id)}

  \begin{itemize}
  \tightlist
  \item
    request has to be sent on url
    \texttt{localhost:8000/cards/tags/tag\_id/}
  \item
    returns Json object with all information about tag specified by
    \texttt{tag\_id}
  \item
    returns
    \texttt{\{id,\ tag\_name,\ success\_rate,\ card\_count,\ cards\}}
  \end{itemize}
\item
  request \texttt{card(card\_id)}

  \begin{itemize}
  \tightlist
  \item
    request has to be sent on url
    \texttt{localhost:8000/cards/cards/card\_id/}
  \item
    returns Json object with all information about card specified by
    \texttt{card\_id}
  \item
    returns
    \texttt{\{id,\ card\_front,\ card\_back,\ tag\_count,\ tags\}}
  \end{itemize}
\item
  request \texttt{add\_tag}

  \begin{itemize}
  \tightlist
  \item
    request sent on url \texttt{localhost:8000/cards/add\_tag/}
  \item
    receives Json object from client -
    \texttt{\{type,\ id,\ tag\_name,\ success\_rate,\ card\_count,\ cards\}}
    - by \texttt{type} value decides what change will happen

    \begin{itemize}
    \tightlist
    \item
      adds new tag (\texttt{"type":\ "new}),
    \item
      updates name of a tag (\texttt{"type":\ "update"}),
    \item
      updates success rate of the last test (\texttt{"type":\ "test"}),
    \item
      deletes a tag (\texttt{"type":\ "delete"}).
    \end{itemize}
  \end{itemize}
\item
  request \texttt{add\_card}

  \begin{itemize}
  \tightlist
  \item
    request sent on url \texttt{localhost:8000/cards/add\_card/}
  \item
    receives Json object from client -
    \texttt{\{type,\ id,\ card\_front,\ card\_back,\ tag\_count,\ tags\}}
    - by \texttt{type} value decides what change will happen

    \begin{itemize}
    \tightlist
    \item
      adds new card and automatically updates all tag relationships
      (\texttt{"type":\ "new"}),
    \item
      updates names and relationships (\texttt{"type":\ "update"}),
    \item
      deletes a card (```type'': ``delete'').
    \end{itemize}
  \end{itemize}
\item
  request \texttt{import\_all}

  \begin{itemize}
  \item
    request sent on url \texttt{localhost:8000/cards/import/}
  \item
    receives list of two Json object lists containing both cards and
    tags

    \texttt{{[}}

    ~~~~\texttt{{[}\{type:\ "new",\ card\_front,\ card\_back,\ tag\_count,\ tags\}{]},}

    ~~~~\texttt{{[}\{type:\ "new",\ tag\_name,\ success\_rate:\ 0,\ card\_count:\ 0\}{]}}

    \texttt{{]}}
  \item
    determines if imported item is non-existant and adds it to the
    database - connects tags to cards based on indexes of second list
    (in each tags variable are indexes of second list to connect to) in
    the process
  \item
    if item already exists its skipped
  \end{itemize}
\end{itemize}

In \texttt{urls.py} are defined addresses where to send specific
requests. Each request has its own address for better organization.

\hypertarget{client-side}{%
\section{Client side}\label{client-side}}

User interface client is created in the same way as any modern web
application, but for rendering is used Electron instead of some web
browser such as Firefox or Chrome. Its advantage is that it can be run
offline and in a separate window so it looks much better, but on the
other hand it is necessary to use Node.js so the client takes quite a
lot of memory. As it was said Electron is a framework built on Node.js
so all its packages can be used in the app, such as file manager. This
means the app can access file on the hard drive which would not be
possible, for safety reasons, from simple web app.

\hypertarget{folders-and-files}{%
\subsection{Folders and files}\label{folders-and-files}}

All files for the client are located in \texttt{./user\_interface/}
folder.

\begin{itemize}
\tightlist
\item
  \texttt{/assets/} contains images and icons.
\item
  \texttt{/lib/} contains Bootstrap files, Jquery and custom .css file
  for flipping card.
\item
  \texttt{/node\_modules/} contains all Node.js packages including
  electron; from these will be built final executable.
\item
  \texttt{/src/} contains Javascript and HTML files which define actual
  functionality of the application
\item
  In this file are also \texttt{package-lock.json} and
  \texttt{package.json}

  \begin{itemize}
  \tightlist
  \item
    the first one describes the exact tree of files downloaded into
    node-modules
  \item
    the second one handles starting the app from terminal and also
    packaging the file into executable
  \end{itemize}
\end{itemize}

\hypertarget{structure}{%
\subsection{Structure}\label{structure}}

Contents of all files are described in next chapters, this part
describes only the process. Rendering process starts at the
\texttt{render.js} file which is set to be executed first in
\texttt{package.json}.

This file creates window and loads into it \texttt{mainWindow.html} file
which controls the layout and visual aspect of the app. It is
constructed as a one-page app so everything is declared in one html file
and only currently required parts are shown, the rest is hidden.
Visibility is determined by Javascript file.

The visuals of html layout is enhanced by Bootstrap. To the
\texttt{mainWindow.html} are linked Bootstraps precompiled \texttt{.css}
files, which are modified in order to adjust some colors to app theme,
\texttt{.js} files, which are required for some features, and
\texttt{popper.js}, which is also required by Bootstrap.

To \texttt{mainWindow.html} is also linked \texttt{main.js} file, which
contains all inner functions of the app. For example, it handles what is
visible, getting input from user and sending and receiving requests from
the database. All its functions are described in some of next chapters.

\hypertarget{installing-electron}{%
\subsubsection{Installing Electron}\label{installing-electron}}

~~~~\texttt{npm\ install\ electron\ -\/-save-dev}

\begin{itemize}
\tightlist
\item
  executed in main folder of the project
\end{itemize}

\hypertarget{terminal-command-to-start-client}{%
\subsubsection{Terminal command to start
client}\label{terminal-command-to-start-client}}

~~~~\texttt{npm\ start}

\begin{itemize}
\tightlist
\item
  executed from \texttt{user\_interface} folder
\end{itemize}

\hypertarget{packaging}{%
\subsubsection{Packaging}\label{packaging}}

To package app into folder containing executable and other dependencies
is run by

~~~~\texttt{npm\ run} + one of these
\texttt{package-win/package-linux/pakcage-mac}

This command is defined in the \texttt{package.json} file in attribute
\texttt{"scripts":\ \{\}} and packs file into folder
\texttt{/user\_interface/release-builds/} using
\texttt{electron-packager} and it is functioning without installing
anything. \textbf{But it's only the visual part, the server needs to
have installed Python and Django and it has to be turned manually from
command line or by using shell script added to \texttt{render.js}.}

\hypertarget{render.js}{%
\subsection{render.js}\label{render.js}}

It's a simple file, where are described only looks of the window and
which html it should render.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  On the beggining of the file it is necessary to include Electron and
  assign to it \texttt{app} and \texttt{BrowserWindow} variables.
\item
  Everything else should be in
  \texttt{app.on("ready",\ function()\ \{\ code\ \});} statement, it
  waits before Electron is initialized.
\item
  To \texttt{mainWindow} variable is assigned \texttt{BrowserWindow}
  class - here are defined properties of the window

  \begin{itemize}
  \tightlist
  \item
    Here are set height, width, where should the window appear and its
    title
  \end{itemize}
\item
  With \texttt{.setMenu} are specified items in menu bar (turned off by
  default).
\item
  Loading \texttt{html} code from another file
\item
  Making sure that app will quit after the window is closed
\end{enumerate}

For discovering more about Electron APIs and possibilities visit
(\emph{www.electronjs.org/docs})

\hypertarget{mainwindow.html}{%
\subsection{mainWindow.html}\label{mainwindow.html}}

In the header of this file are many \texttt{link} and \texttt{script}
tags loading Javascript and css extensions. In commented part are online
CDN links in case the linked files are not downloaded. Also there are
two special \texttt{script} tags around the others just for Electron to
load them correctly.

Almost every tags are inheriting from \texttt{bootstrap.css} so they
many classes in themselves. Those which will be accessed from
\texttt{main.js} for dynamical updates are also named by \texttt{id}
property.

Most of the content is dynamically updated so there is almost no
content, these are just prepared to be filled by the data from database.

For discovering more about Bootstrap classes visit its documentation
(\emph{www.getbootstrap.com/docs/4.2/getting-started/introduction/}).

\hypertarget{main.js}{%
\subsection{main.js}\label{main.js}}

This file contains combination of JQuery APIs and plain Javascript. By
definition everything from JQuery begins with \texttt{\$} sign and it
provides better communication with \texttt{html} file and it makes
handling requests easier.

After the \texttt{mainWindow.html} is loaded into Electron and
everything is set up, the block inside
\texttt{\$(document).ready(function()\ \{\});} is executed first. It
calls the \texttt{reset()} function, which hides everything except title
page, and it waits for pressing any of the buttons in navigation bar and
calls corresponding function when done so.

\hypertarget{home-button}{%
\subsubsection{Home button}\label{home-button}}

Calls only the \texttt{reset()} function and shows title page.

\hypertarget{other-functions}{%
\subsubsection{Other functions}\label{other-functions}}

\begin{itemize}
\tightlist
\item
  \texttt{hide\_all()} - hides every div; only navigation bar remains
\item
  \texttt{reset()} - calls \texttt{hide\_all()} and shows title page
\item
  \texttt{show\_one\_item(item)} - takes id of div to show as an
  argument; calls \texttt{hide\_all()} and shows \texttt{item}
\item
  \texttt{post\_information(suffix,\ data)} - takes suffix to
  \texttt{database\_path} to send data to and data as arguments; makes
  \textbf{ajax POST} request with json object
\item
  \texttt{load\_information(suffix)} - takes suffix to
  \texttt{database\_path} to get data from; makes \textbf{ajax GET}
  request and returns data from the specified path
\item
  \texttt{create\_card\_object(type,\ id,\ card\_front,\ card\_back,\ tags)}

  \begin{itemize}
  \tightlist
  \item
    returns string of JSON card object with values from arguments
  \end{itemize}
\item
  \texttt{create\_tag\_object(type,\ id,\ tag\_name,\ success\_rate,\ card\_count,\ cards)}

  \begin{itemize}
  \tightlist
  \item
    returns string of JSON tag object with values from arguments
  \end{itemize}
\end{itemize}

\hypertarget{click-events}{%
\subsubsection{Click events}\label{click-events}}

\begin{itemize}
\tightlist
\item
  Every \textbf{click} event has to be \texttt{unbind()}, otherwise the
  events would stack up and after second press of the button the
  function would be called twice and so on.
\item
  Inside every \textbf{click} event should be called
  \texttt{event.preventDefault();}. This app uses JQuery for handling
  button clicks so we need to disable the \texttt{html} handling the
  clicks. Otherwise the page would refresh and we would see title page
  again.
\end{itemize}
\end{document}